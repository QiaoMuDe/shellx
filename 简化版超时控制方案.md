# ShellX 简化版超时控制方案

## 设计理念

完全去掉Builder模式，让Command承担配置、构建、执行的全部职责，实现真正的一体化设计。

## 核心设计

### 1. Command结构体 - 一体化设计

```go
// Command 命令对象 - 集配置、构建、执行于一体
type Command struct {
    // 基本命令配置
    shellType ShellType       // shell类型
    raw       string          // 原始命令字符串
    name      string          // 命令名
    args      []string        // 命令参数
    
    // 执行环境配置
    dir       string          // 工作目录
    env       []string        // 环境变量
    stdin     io.Reader       // 标准输入
    stdout    io.Writer       // 标准输出
    stderr    io.Writer       // 标准错误输出
    
    // 上下文和超时配置
    userCtx   context.Context  // 用户设置的上下文
    timeout   time.Duration    // 超时时间
    
    // 执行状态和控制
    execCmd   *exec.Cmd        // 真正的exec.Cmd对象（延迟创建）
    cancel    context.CancelFunc // 超时上下文的取消函数
    execOne   atomic.Bool      // 确保只执行一次
    mu        sync.RWMutex     // 保护配置字段的并发安全
}
```

### 2. 创建函数 - 直接返回Command

```go
// NewCmd 创建新的命令对象 (数组方式 - 可变参数)
func NewCmd(name string, args ...string) *Command {
    if name == "" {
        panic("name cannot be empty")
    }

    return &Command{
        name:      name,
        args:      args,
        env:       os.Environ(),   // 默认继承父进程的环境变量
        shellType: ShellDefault,   // 默认根据操作系统自动选择shell
        mu:        sync.RWMutex{},
    }
}

// NewCmds 创建新的命令对象 (数组方式 - 切片参数)
func NewCmds(cmdArgs []string) *Command {
    if len(cmdArgs) == 0 {
        return &Command{}
    }

    name := cmdArgs[0]
    args := []string{}
    if len(cmdArgs) > 1 {
        args = cmdArgs[1:]
    }

    return NewCmd(name, args...)
}

// NewCmdStr 创建新的命令对象 (字符串方式)
func NewCmdStr(cmdStr string) *Command {
    cmds := ParseCmd(cmdStr)
    cmd := NewCmds(cmds)
    cmd.raw = cmdStr // 保存原始命令字符串
    return cmd
}
```

### 3. 配置方法 - 链式调用

```go
// WithWorkDir 设置命令的工作目录
func (c *Command) WithWorkDir(dir string) *Command {
    c.mu.Lock()
    defer c.mu.Unlock()

    if dir != "" {
        c.dir = dir
    }
    return c
}

// WithEnv 设置命令的环境变量
func (c *Command) WithEnv(key, value string) *Command {
    c.mu.Lock()
    defer c.mu.Unlock()

    if c.env == nil {
        c.env = os.Environ()
    }

    if key != "" {
        c.env = append(c.env, fmt.Sprintf("%s=%s", key, value))
    }
    return c
}

// WithEnvs 批量设置命令的环境变量
func (c *Command) WithEnvs(envs []string) *Command {
    c.mu.Lock()
    defer c.mu.Unlock()

    if len(envs) == 0 {
        return c
    }

    if c.env == nil {
        c.env = os.Environ()
    }

    // 验证环境变量格式，只添加验证通过的环境变量
    validEnvs := make([]string, 0, len(envs))
    for _, env := range envs {
        if err := validateEnvVar(env); err == nil {
            validEnvs = append(validEnvs, env)
        }
    }

    c.env = append(c.env, validEnvs...)
    return c
}

// WithTimeout 设置命令的超时时间（便捷方法）
func (c *Command) WithTimeout(timeout time.Duration) *Command {
    c.mu.Lock()
    defer c.mu.Unlock()

    if timeout > 0 {
        c.timeout = timeout
    }
    return c
}

// WithContext 设置命令的上下文（用户上下文优先）
func (c *Command) WithContext(ctx context.Context) *Command {
    c.mu.Lock()
    defer c.mu.Unlock()

    if ctx == nil {
        panic("context cannot be nil")
    }
    c.userCtx = ctx
    return c
}

// WithStdin 设置命令的标准输入
func (c *Command) WithStdin(stdin io.Reader) *Command {
    c.mu.Lock()
    defer c.mu.Unlock()

    if stdin == nil {
        panic("stdin cannot be nil")
    }
    c.stdin = stdin
    return c
}

// WithStdout 设置命令的标准输出
func (c *Command) WithStdout(stdout io.Writer) *Command {
    c.mu.Lock()
    defer c.mu.Unlock()

    if stdout == nil {
        panic("stdout cannot be nil")
    }
    c.stdout = stdout
    return c
}

// WithStderr 设置命令的标准错误输出
func (c *Command) WithStderr(stderr io.Writer) *Command {
    c.mu.Lock()
    defer c.mu.Unlock()

    if stderr == nil {
        panic("stderr cannot be nil")
    }
    c.stderr = stderr
    return c
}

// WithShell 设置命令的shell类型
func (c *Command) WithShell(shell ShellType) *Command {
    c.mu.Lock()
    defer c.mu.Unlock()

    c.shellType = shell
    return c
}
```

### 4. 获取配置的方法

```go
// ShellType 获取shell类型
func (c *Command) ShellType() ShellType {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.shellType
}

// Raw 获取原始命令字符串
func (c *Command) Raw() string {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.raw
}

// Name 获取命令名称
func (c *Command) Name() string {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.name
}

// Args 获取命令参数列表
func (c *Command) Args() []string {
    c.mu.RLock()
    defer c.mu.RUnlock()
    tempArgs := make([]string, len(c.args))
    copy(tempArgs, c.args)
    return tempArgs
}

// WorkDir 获取命令执行的工作目录
func (c *Command) WorkDir() string {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.dir
}

// Env 获取命令环境变量列表
func (c *Command) Env() []string {
    c.mu.RLock()
    defer c.mu.RUnlock()
    tempEnv := make([]string, len(c.env))
    copy(tempEnv, c.env)
    return tempEnv
}

// Timeout 获取命令执行超时时间
func (c *Command) Timeout() time.Duration {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.timeout
}
```

### 5. 核心方法 - 延迟构建exec.Cmd

```go
// buildExecCmd 在执行时构建真正的exec.Cmd对象
func (c *Command) buildExecCmd() {
    if c.execCmd != nil {
        return // 已经构建过了
    }
    
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    var finalCtx context.Context
    
    // 上下文优先级判断
    if c.userCtx != nil {
        // 用户设置了上下文，直接使用（忽略timeout）
        finalCtx = c.userCtx
    } else if c.timeout > 0 {
        // 没有用户上下文但设置了超时，创建超时上下文
        ctx, cancel := context.WithTimeout(context.Background(), c.timeout)
        c.cancel = cancel // 保存cancel函数用于资源清理
        finalCtx = ctx
    } else {
        // 都没有设置，使用默认上下文
        finalCtx = context.Background()
    }
    
    // 根据shell类型创建exec.Cmd
    if c.shellType != ShellNone {
        // 使用shell执行命令
        cmdStr := c.getCmdStr()
        c.execCmd = exec.CommandContext(finalCtx, c.shellType.String(), c.shellType.shellFlags(), cmdStr)
    } else {
        // 不使用shell执行命令
        c.execCmd = exec.CommandContext(finalCtx, c.name, c.args...)
    }
    
    // 设置exec.Cmd的其他属性
    c.execCmd.Dir = c.dir
    c.execCmd.Env = c.env
    c.execCmd.Stdin = c.stdin
    c.execCmd.Stdout = c.stdout
    c.execCmd.Stderr = c.stderr
}

// getCmdStr 根据配置生成命令字符串
func (c *Command) getCmdStr() string {
    if c.raw != "" {
        return c.raw
    }
    
    if len(c.args) == 0 {
        return c.name
    }
    
    // 简单拼接，实际可能需要更复杂的逻辑处理特殊字符
    return c.name + " " + strings.Join(c.args, " ")
}
```

### 6. 执行方法 - 统一的执行逻辑

```go
// Exec 执行命令(阻塞)
func (c *Command) Exec() error {
    if !c.execOne.CompareAndSwap(false, true) {
        return fmt.Errorf("command has already been executed")
    }
    
    // 执行时才构建真正的exec.Cmd
    c.buildExecCmd()
    
    // 确保资源清理
    defer c.cleanup()
    
    return c.execCmd.Run()
}

// ExecOutput 执行命令并返回合并后的输出(阻塞)
func (c *Command) ExecOutput() ([]byte, error) {
    if !c.execOne.CompareAndSwap(false, true) {
        return nil, fmt.Errorf("command has already been executed")
    }
    
    // 执行时才构建真正的exec.Cmd
    c.buildExecCmd()
    
    // 确保资源清理
    defer c.cleanup()
    
    return c.execCmd.CombinedOutput()
}

// ExecStdout 执行命令并返回标准输出(阻塞)
func (c *Command) ExecStdout() ([]byte, error) {
    if !c.execOne.CompareAndSwap(false, true) {
        return nil, fmt.Errorf("command has already been executed")
    }
    
    // 执行时才构建真正的exec.Cmd
    c.buildExecCmd()
    
    // 确保资源清理
    defer c.cleanup()
    
    return c.execCmd.Output()
}

// ExecResult 执行命令并返回完整的执行结果(阻塞)
func (c *Command) ExecResult() (*Result, error) {
    if !c.execOne.CompareAndSwap(false, true) {
        return nil, fmt.Errorf("command has already been executed")
    }
    
    // 执行时才构建真正的exec.Cmd
    c.buildExecCmd()
    
    // 确保资源清理
    defer c.cleanup()
    
    // 命令执行开始时间
    startTime := time.Now()
    
    // 执行命令
    output, err := c.execCmd.CombinedOutput()
    
    // 命令执行结束时间
    endTime := time.Now()
    
    // 获取命令的退出码
    var exitCode int
    if err != nil {
        exitCode = -1
    }
    
    // 创建Result对象
    result := &Result{
        startTime: startTime,
        endTime:   endTime,
        duration:  endTime.Sub(startTime),
        output:    output,
        success:   err == nil,
        exitCode:  exitCode,
    }
    
    return result, err
}

// ExecAsync 异步执行命令(非阻塞)
func (c *Command) ExecAsync() error {
    if !c.execOne.CompareAndSwap(false, true) {
        return fmt.Errorf("command has already been executed")
    }
    
    // 执行时才构建真正的exec.Cmd
    c.buildExecCmd()
    
    return c.execCmd.Start()
}

// Wait 等待命令执行完成(仅在异步执行时有效)
func (c *Command) Wait() error {
    if c.execCmd == nil {
        return fmt.Errorf("command has not been started")
    }
    
    err := c.execCmd.Wait()
    
    // 清理资源
    c.cleanup()
    
    return err
}

// cleanup 清理资源
func (c *Command) cleanup() {
    if c.cancel != nil {
        c.cancel()
        c.cancel = nil
    }
}
```

### 7. 其他辅助方法

```go
// Cmd 获取底层的 exec.Cmd 对象
func (c *Command) Cmd() *exec.Cmd {
    if c.execCmd == nil {
        c.buildExecCmd() // 如果还没构建，先构建
    }
    return c.execCmd
}

// Kill 杀死当前命令的进程
func (c *Command) Kill() error {
    if c.execCmd == nil || c.execCmd.Process == nil {
        return fmt.Errorf("no process to kill")
    }
    return c.execCmd.Process.Kill()
}

// Signal 向当前进程发送信号
func (c *Command) Signal(sig os.Signal) error {
    if c.execCmd == nil || c.execCmd.Process == nil {
        return fmt.Errorf("no process to signal")
    }
    return c.execCmd.Process.Signal(sig)
}

// IsRunning 检查进程是否还在运行
func (c *Command) IsRunning() bool {
    if c.execCmd == nil || c.execCmd.Process == nil {
        return false
    }

    if c.execCmd.ProcessState != nil {
        return false // 进程已结束
    }

    // 尝试发送信号0检查进程是否存在
    err := c.execCmd.Process.Signal(syscall.Signal(0))
    return err == nil
}

// GetPID 获取进程ID
func (c *Command) GetPID() int {
    if c.execCmd == nil || c.execCmd.Process == nil {
        return 0
    }
    return c.execCmd.Process.Pid
}

// IsExecuted 检查命令是否已经执行过
func (c *Command) IsExecuted() bool {
    return c.execOne.Load()
}
```

### 8. 便捷函数保持不变

```go
// ExecStr 执行命令(阻塞)
func ExecStr(cmdStr string) error {
    return NewCmdStr(cmdStr).WithStdout(os.Stdout).WithStderr(os.Stderr).Exec()
}

// Exec 执行命令(阻塞)
func Exec(name string, args ...string) error {
    return NewCmd(name, args...).WithStdout(os.Stdout).WithStderr(os.Stderr).Exec()
}

// ExecOutputStr 执行命令并返回合并后的输出(阻塞)
func ExecOutputStr(cmdStr string) ([]byte, error) {
    return NewCmdStr(cmdStr).ExecOutput()
}

// ExecOutput 执行命令并返回合并后的输出(阻塞)
func ExecOutput(name string, args ...string) ([]byte, error) {
    return NewCmd(name, args...).ExecOutput()
}
```

## 使用示例

```go
// 1. 基本使用（无需Build）
cmd := NewCmd("sleep", "10").WithTimeout(3*time.Second)
err := cmd.Exec() // 3秒后超时

// 2. 链式调用
err := NewCmd("ls", "-la").
    WithWorkDir("/tmp").
    WithTimeout(5*time.Second).
    WithStdout(os.Stdout).
    Exec()

// 3. 用户上下文优先
ctx, cancel := context.WithCancel(context.Background())
defer cancel()

err := NewCmd("sleep", "10").
    WithContext(ctx).
    WithTimeout(3*time.Second). // 这个会被忽略
    Exec()

// 4. 字符串方式
output, err := NewCmdStr("echo hello world").
    WithTimeout(1*time.Second).
    ExecOutput()
```

## 优势总结

### 1. 极简设计
- 去掉了Builder，减少了一层抽象
- 用户直接操作Command对象，更直观
- 无需调用Build()方法

### 2. 精确超时控制
- 超时上下文在执行时创建，计时精确
- 避免了配置到执行之间的时间损耗

### 3. 清晰的优先级
- 用户上下文优先于便捷超时方法
- 逻辑简单明了

### 4. 完整的功能
- 保留了所有原有功能
- API使用方式基本不变（除了不需要Build）
- 支持链式调用

### 5. 资源管理
- 自动管理超时上下文的cancel函数
- 确保资源正确释放

这个设计彻底简化了架构，让Command成为真正的一体化对象！